{
    "structure": {
        "type0_comman_configuration_space": {
            "info": {
                "offset": 0,
                "size": 64
            },
            "registers": [
                "vendor_id",
                "device_id",
                "command"
            ]
        }
    },

    "register": {
        "vendor_id": {
            "offset": 0,
            "size": 2,
            "fields": [{
                "bit": 0,
                "bit_width": 16,
                "name": "vendor_id",
                "default": 65535,
                "description": "For non-VFs, the Vendor ID register is HwInit and the value in this register identifies the manufacturer of the Function. In\nkeeping with PCI-SIG procedures, valid vendor identifiers must be allocated by the PCI-SIG to ensure uniqueness. Each\nvendor must have at least one Vendor ID. It is recommended that software read the Vendor ID register to determine if a\nFunction is present, where a value of FFFFh indicates that no Function is present.\nFor VFs, this field must return FFFFh when read. VI software should return the Vendor ID value from the associated PF as\nthe Vendor ID value for the VF.",
                "attributes": "RO"
            }]
        },

        "device_id": {
            "offset": 2,
            "size": 2,
            "fields": [{
                "bit": 0,
                "bit_width": 16,
                "name": "device_id",
                "default": 65535,
                "description": "For non-VFs, the Device ID register is HwInit and the value in this register identifies the particular Function. The Device ID\nmust be allocated by the vendor. The Device ID, in conjunction with the Vendor ID and Revision ID, are used as one\nmechanism for software to determine which driver should be loaded. The vendor must ensure that the chosen values do\nnot result in the use of an incompatible device driver.\nFor VFs, this field must return FFFFh when read. VI software should return the VF Device ID (see ยง Section 9.3.3.11 ) value\nfrom the associated PF as the Device ID for the VF.",
                "attributes": "RO"
            }]
        },

        "command": {
            "offset": 4,
            "size": 2,
            "fields": [{
                    "bit": 0,
                    "bit_width": 1,
                    "name": "io_space_enable",
                    "default": 0,
                    "value_parse": {
                        "0": "I/O decoding disabled",
                        "1": "I/O decoding enabled"
                    },
                    "description": "Controls a Function's response to I/O Space accesses. When this bit is Clear, all\nreceived I/O accesses are caused to be handled as Unsupported Requests. When this bit is Set, the\nFunction is enabled to decode the address and further process I/O Space accesses. For a Function with a\nType 1 Configuration Space Header, this bit controls the response to I/O Space accesses received on its\nPrimary Side.\nDefault value of this bit is 0b.\nThis bit is permitted to be hardwired to Zero if a Function does not support I/O Space accesses.\nThis bit does not apply to VFs and must be hardwired to Zero.",
                    "attributes": "RW\nVF ROZ"
                },
                {
                    "bit": 1,
                    "bit_width": 1,
                    "name": "memory_space_enable",
                    "default": 0,
                    "value_parse": {
                        "0": "Memory decoding disabled",
                        "1": "Memory decoding enabled"
                    },
                    "description": "Controls a Function's response to Memory Space accesses. When this bit is\nClear, all received Memory Space accesses are caused to be handled as Unsupported Requests. When\nthis bit is Set, the Function is enabled to decode the address and further process Memory Space\naccesses. For a Function with a Type 1 Configuration Space Header, this bit controls the response to\nMemory Space accesses received on its Primary Side.\nDefault value of this bit is 0b.\nThis bit is permitted to be hardwired to 0b if a Function does not support Memory Space accesses.\nThis bit does not apply to VFs and must be hardwired to Zero. VF Memory Space is controlled by the VF\nMSE bit in the SR-IOV Control Register.",
                    "attributes": "RW\nVF ROZ"
                }
            ]
        }
    }
}